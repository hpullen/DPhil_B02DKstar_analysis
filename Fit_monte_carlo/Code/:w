#include <iostream>
#include <fstream>

#include "TApplication.h"
#include "TCanvas.h"
#include "TFile.h"
#include "TChain.h"
#include "TH1F.h"

#include "RooCruijff.h"
#include "RooGlobalFunc.h"
#include "RooExponential.h"
#include "RooAddPdf.h"
#include "RooArgList.h"
#include "RooArgSet.h"
#include "RooCBShape.h"
#include "RooDataSet.h"
#include "RooFitResult.h"
#include "RooFormulaVar.h"
#include "RooHist.h"
#include "RooPlotable.h"
#include "RooPlot.h"
#include "RooRealVar.h"

#include "Plotter.hpp"

// Fit to misID version of invariant mass
void fit_misID() {

    // Load Dpipi data
    std::string path = "/data/lhcb/users/pullen/B02DKstar/MC/backgrounds/Dpipi/";
    TChain *  tree = new TChain("DecayTree");
    tree->Add((path + "2016_down/Kpi_selected_withMisIDmass.root").c_str());
    tree->Add((path + "2016_up/Kpi_selected_withMisIDmass.root").c_str());

    // Set variables
    // To do: add double mis-ID cut to ADS modes
    RooRealVar Bd_M("misID_M", "", 5250, 5800, "MeV/c^{2}");
    // RooRealVar KstarK_PIDK("KstarK_PIDK", "", 5, 1000000);
    RooRealVar PID_efficiency("PID_efficiency", "", 0, 1);

    // Set up bins
    int binWidth = 5;
    double nBins = (Bd_M.getMax() - Bd_M.getMin()) / binWidth;
    Bd_M.setBins(nBins);

    // Make args and dataset
    RooArgList args;
    args.add(Bd_M);
    args.add(PID_efficiency);
    RooDataSet * data = new RooDataSet("data", "", tree, args, 0, "PID_efficiency");

    // Fit parameters
    RooRealVar * mean = new RooRealVar("mean", "", 5320, 5200, 5500);
    // RooRealVar * sigma_L = new RooRealVar("sigma_L", "", 25, 0, 50);
    // RooRealVar * sigma_ratio = new RooRealVar("sigma_ratio", "", 0.02, 0, 1);
    // RooFormulaVar * sigma_R = new RooFormulaVar("sigma_R", "@0 * @1", 
        // RooArgList(*sigma_L, *sigma_ratio));
    // RooRealVar * alpha_L = new RooRealVar("alpha_L", "", 1.5, 0.5, 10);
    // RooRealVar * alpha_R = new RooRealVar("alpha_R", "", -0.3, -5, -0.001);
    // RooRealVar * n_L = new RooRealVar("n_L", "", 1);
    // // RooRealVar * n_R = new RooRealVar("n_L", "", 1);
    // RooRealVar * n_R = new RooRealVar("n_R", "", 9, 0, 10);
    // RooRealVar * frac = new RooRealVar("frac", "", 0.2, 0, 1);

    // Fix parameters to those from rho shape
    // RooRealVar * mean = new RooRealVar("mean", "", 5321.48);
    RooRealVar * sigma_L = new RooRealVar("sigma_L", "", 17.7197);
    RooRealVar * sigma_ratio = new RooRealVar("sigma_ratio", "", 0.764283);
    RooFormulaVar * sigma_R = new RooFormulaVar("sigma_R", "@0 * @1", 
            RooArgList(*sigma_L, *sigma_ratio));
    RooRealVar * alpha_L = new RooRealVar("alpha_L", "", 2.2007);
    RooRealVar * alpha_R = new RooRealVar("alpha_R", "", -0.50275);
    RooRealVar * n_L = new RooRealVar("n_L", "", 1);
    RooRealVar * n_R = new RooRealVar("n_R", "", 9.0308);
    RooRealVar * frac = new RooRealVar("frac", "", 0.287588);

    // PDFs
    RooCBShape * signal_L = new RooCBShape("signal_L", "", Bd_M, *mean, *sigma_L,
            *alpha_L, *n_L);
    RooCBShape * signal_R = new RooCBShape("signal_R", "", Bd_M, *mean, *sigma_R,
            *alpha_R, *n_R);
    RooAddPdf * signal = new RooAddPdf("signal", "", RooArgList(*signal_L, 
                *signal_R), RooArgList(*frac));

    // Make exponential for background
    RooRealVar * slope = new RooRealVar("slope", "", -0.005, -0.007, 0.0);
    RooExponential * expo = new RooExponential("expo", "", Bd_M, *slope);

    // Combine
    RooRealVar * f_signal = new RooRealVar("f_signal", "", 0.8, 0, 1);
    RooAddPdf * pdf = new RooAddPdf("pdf", "", RooArgList(*signal, *expo),
            RooArgList(*f_signal));

    // Fit to the dataset
    std::cout << "Dataset entries: " << data->sumEntries() << std::endl;
    RooFitResult * r = pdf->fitTo(*data, RooFit::Save(), RooFit::NumCPU(8, 2),
            RooFit::Optimize(false), RooFit::Offset(true), 
            RooFit::Minimizer("Minuit2", "migrad"), RooFit::Strategy(2));
    r->Print("v");

    // Save output to a file
    std::ofstream params("../Results/Dpipi.param");
    params << "alpha_L " << alpha_L->getVal() << " " << alpha_L->getError() << std::endl;
    params << "alpha_R " << alpha_R->getVal() << " " << alpha_R->getError() << std::endl;
    params << "frac " << frac->getVal() << " " << frac->getError() << std::endl;
    params << "mean " << mean->getVal() << " " << mean->getError() << std::endl;
    params << "n_L " << n_L->getVal() << " " << n_L->getError() << std::endl;
    params << "n_R " << n_R->getVal() << " " << n_R->getError() << std::endl;
    params << "sigma_L " << sigma_L->getVal() << " " << sigma_L->getError() << std::endl;
    params << "sigma_ratio " << sigma_ratio->getVal() << " " << sigma_ratio->getError() << std::endl;
    params << "slope" << slope->getVal() << " " << slope->getError() << std::endl;
    params << "f_signal" << f_signal->getVal() << " " << f_signal->getError() << std::endl;
    params.close();

    // Convert PDFs to TH1s
    TFile * outfile = TFile::Open("../Histograms/Dpipi_Kpi.root", "RECREATE");
    TH1F * h_data = (TH1F*)data->createHistogram("data", Bd_M);
    TH1F * h_fit = (TH1F*)pdf->createHistogram("fit", Bd_M, 
            RooFit::Binning(nBins * 10));
    TH1F * h_signal = (TH1F*)signal->createHistogram("signal", Bd_M, 
            RooFit::Binning(nBins * 10));
    TH1F * h_expo = (TH1F*)expo->createHistogram("comb", Bd_M, 
            RooFit::Binning(nBins * 10));
    // TH1F * h_CB_L = (TH1F*)signal_L->createHistogram("CB_L", Bd_M,
            // RooFit::Binning(nBins * 10));
    // TH1F * h_CB_R = (TH1F*)signal_R->createHistogram("CB_R", Bd_M,
            // RooFit::Binning(nBins * 10));

    // Scale histograms
    h_fit->Scale(h_data->Integral() * 10);
    h_signal->Scale(h_data->Integral() * 10 * f_signal->getVal());
    h_expo->Scale(h_data->Integral() * 10 * (1 - f_signal->getVal()));
    // h_CB_L->Scale(h_data->Integral() * 10 * frac->getVal());
    // h_CB_R->Scale(h_data->Integral() * 10 * (1 - frac->getVal()));

    // Plot the fit and display it in TApplication
    RooPlot * frame = Bd_M.frame(RooFit::Title(""));
    data->plotOn(frame);
    signal->plotOn(frame);
    RooHist * pulls = frame->pullHist();

    // Save histograms and pulls to file
    outfile->cd();
    h_data->Write("data");
    h_fit->Write("fit");
    h_signal->Write("signal");
    h_expo->Write("comb");
    // h_CB_L->Write("CB_L");
    // h_CB_R->Write("CB_R");
    pulls->Write("pulls");
    r->Write("fit_result");
    outfile->Close();

    // Plot the results nicely
    Plotter * plotter = new Plotter("Kpi", "Dpipi");
    plotter->plotFit("signal", "comb");

}

// Fit to signal and apply sWeights
void fit_signal(TString mag) {

    // Load data
    std::string path = "/data/lhcb/users/pullen/B02DKstar/MC/backgrounds/Dpipi/";
    TChain *  tree = new TChain("DecayTree");
    tree->Add((path + "2016_down/Kpi_selected_withMisIDmass.root").c_str());
    tree->Add((path + "2016_up/Kpi_selected_withMisIDmass.root").c_str());
    RooRealVar Bd_M("B_ConstD0_M", "", 5000, 5800, "MeV/c^{2}");

    // Set up bins
    int binWidth = 5;
    double nBins = (Bd_M.getMax() - Bd_M.getMin()) / binWidth;
    Bd_M.setBins(nBins);

    // Make args and dataset
    RooArgList args;
    args.add(Bd_M);
    RooDataSet * data = new RooDataSet("data", "", tree, args);

    // Make signal shape
    RooRealVar * mean = new RooRealVar("mean", "", 5280, 5200, 5400);
    RooRealVar * sigma_L = new RooRealVar("sigma_L", "", 9, 5, 15);
    RooRealVar * frac = new RooRealVar("frac", "", 0.5, 0, 1);
    RooRealVar * sigma_ratio = new RooRealVar("sigma_ratio", "", 1, 0, 10);
    RooRealVar * sigma_R = new RooFormulaVar("sigma_R", "@0 * @1", 
            RooArgList(*sigma_L, *sigma_ratio));
    RooRealVar * alpha_L = new RooRealVar("alpha_L", "", 1.5, 0, 3);
    RooRealVar * alpha_R = new RooRealVar("alpha_R", "", 0.1, 0, 3);
    RooRealVar * n_L = new RooRealVar("n_L", "", 6, 0, 10);
    RooRealVar * n_R = new RooRealVar("n_R", "", 6, 0, 10);
    RooCruijff * signal = new RooCruijff("signal", "", Bd_M, *mean, *sigma_L,
                *sigma_R, *alpha_L, *alpha_R);

    // Make exponential for background
    RooRealVar * slope = new RooRealVar("slope", "", -0.005, -0.007, 0.0);
    RooExponential * expo = new RooExponential("expo", "", Bd_M, *slope);

    // Combine
    double entries = tree->GetEntries();
    RooRealVar * N_signal = new RooRealVar("f_signal", "", 0.8*entries, 0, entries);
    RooRealVar * N_expo = new RooRealVar("f_signal", "", 0.2*entries, 0, entries);
    RooAddPdf * pdf = new RooAddPdf("pdf", "", RooArgList(*signal, *expo),
            RooArgList(*N_signal, *N_expo));

    // Perform the fit
    RooFitResult * r = pdf->fitTo(*data, RooFit::Save());
    r->Print();

    // Plot fit
    RooPlot * plt = Bd_M.frame();
    data->plotOn(plt, RooFit::DrawOption("PZ"), RooFit::LineWidth(1), 
            RooFit::LineColor(kBlack));
    pdf->plotOn(plt, RooFit::LineColor(kBlack), RooFit::DrawOption("C"), 
            RooFit::LineWidth(2), RooFit::ProjWData(*data));
    pdf->plotOn(plt, RooFit::LineColor(ANABlue), RooFit::DrawOption("C"), 
            RooFit::LineWidth(2), RooFit::ProjWData(*data), 
            RooFit::Components("expo"));
    pdf->plotOn(plt, RooFit::LineColor(kRed + 2), RooFit::DrawOption("C"), 
            RooFit::LineWidth(2), RooFit::ProjWData(*data), 
            RooFit::Components("signal"));
    TCanvas * canvas = new TCanvas("canv", "", 900, 600);
    plt->Draw();
    canvas->SaveAs("../Plots/Dpipi_signal.pdf");

    // Set non-yield params constant
    mean->setConstant();
    sigma_L->setConstant();
    alpha_L->setConstant();
    alpha_R->setConstant();
    n_L->setConstant();
    n_R->setConstant();
    slope->setConstant(); 

    // Get sWeights
    RooStats::SPlot * sData = new RooStats::SPlot("sData", "", *data, model, 
            RooArgList(*N_signal, *N_expo));
    sData->GetSWeightVars().Print();

    // Make output tree
    TFile * outfile = new TFile(("/data/lhcb/users/pullen/B02DKstar/MC/"
            "backgrounds/Dpipi/
            "RECREATE");
    TTree * outtree = tree->CloneTree(0);
    Double_t sw_signal;
    outtree->Branch("sw_signal", &sw_signal, "sw_signal/D");
    Double_t mass;
    tree->SetBranchAddress("Bd_ConsD_MD", &mass);

    int nentries = tree->GetEntries();
    int n_in_range = 0;
    for (Long64_t n_e = 0; n_e < nentries; n_e++) {
        Long64_t entry = tree->GetEntryNumber(n_e);
        tree->GetEntry(entry);
        // Check mass is in range
        if (5000 < mass && mass < 5800){
            // Extract sWeights
            sw_signal = sData->GetSWeight(n_in_range, "n_sig");
            n_in_range++;
            outtree->Fill();
        }
    }

    // Save
    outtree->Write("DecayTree");
    outfile->Close();


}



// Program for fitting to Dpipi data 
int main(int argc, char * argv[]) {

    if (argc > 1 && argv[1] == "--sWeight") {
        if (argc == 2) {
            std::cout << "Usage: ./FitDpipi --sWeight <up/down>" << std::endl;
        fit_signal(argv[2]);
    } else {
        fit_misID();
    }
    
    return 0;
}
